{"ast":null,"code":"/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n(function () {\n  \"use strict\"; // math-inlining.\n\n  var abs = Math.abs,\n      min = Math.min,\n      max = Math.max,\n      cos = Math.cos,\n      sin = Math.sin,\n      acos = Math.acos,\n      sqrt = Math.sqrt,\n      pi = Math.PI,\n      // a zero coordinate, which is surprisingly useful\n  ZERO = {\n    x: 0,\n    y: 0,\n    z: 0\n  }; // quite needed\n\n  var utils = require(\"./utils.js\"); // only used for outlines atm.\n\n\n  var PolyBezier = require(\"./poly-bezier.js\");\n  /**\n   * Bezier curve constructor. The constructor argument can be one of three things:\n   *\n   * 1. array/4 of {x:..., y:..., z:...}, z optional\n   * 2. numerical array/8 ordered x1,y1,x2,y2,x3,y3,x4,y4\n   * 3. numerical array/12 ordered x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4\n   *\n   */\n\n\n  var Bezier = function (coords) {\n    var args = coords && coords.forEach ? coords : [].slice.call(arguments);\n    var coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      var newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    var higher = false;\n    var len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n      }\n    }\n\n    var _3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== \"undefined\";\n\n    this._3d = _3d;\n    var points = [];\n\n    for (var idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1]\n      };\n\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n\n      points.push(point);\n    }\n\n    this.order = points.length - 1;\n    this.points = points;\n    var dims = [\"x\", \"y\"];\n    if (_3d) dims.push(\"z\");\n    this.dims = dims;\n    this.dimlen = dims.length;\n\n    (function (curve) {\n      var order = curve.order;\n      var points = curve.points;\n      var a = utils.align(points, {\n        p1: points[0],\n        p2: points[order]\n      });\n\n      for (var i = 0; i < a.length; i++) {\n        if (abs(a[i].y) > 0.0001) {\n          curve._linear = false;\n          return;\n        }\n      }\n\n      curve._linear = true;\n    })(this);\n\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  };\n\n  var svgToBeziers = require(\"./svg-to-beziers\");\n  /**\n   * turn an svg <path> d attribute into a sequence of Bezier segments.\n   */\n\n\n  Bezier.SVGtoBeziers = function (d) {\n    return svgToBeziers(Bezier, d);\n  };\n\n  function getABC(n, S, B, E, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n\n    var u = utils.projectionratio(t, n),\n        um = 1 - u,\n        C = {\n      x: u * S.x + um * E.x,\n      y: u * S.y + um * E.y\n    },\n        s = utils.abcratio(t, n),\n        A = {\n      x: B.x + (B.x - C.x) / s,\n      y: B.y + (B.y - C.y) / s\n    };\n    return {\n      A: A,\n      B: B,\n      C: C\n    };\n  }\n\n  Bezier.quadraticFromPoints = function (p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } // shortcuts, although they're really dumb\n\n\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    } // real fitting.\n\n\n    var abc = getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  };\n\n  Bezier.cubicFromPoints = function (S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n\n    var abc = getABC(3, S, B, E, t);\n\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n\n    var d2 = d1 * (1 - t) / t;\n    var selen = utils.dist(S, E),\n        lx = (E.x - S.x) / selen,\n        ly = (E.y - S.y) / selen,\n        bx1 = d1 * lx,\n        by1 = d1 * ly,\n        bx2 = d2 * lx,\n        by2 = d2 * ly; // derivation of new hull coordinates\n\n    var e1 = {\n      x: B.x - bx1,\n      y: B.y - by1\n    },\n        e2 = {\n      x: B.x + bx2,\n      y: B.y + by2\n    },\n        A = abc.A,\n        v1 = {\n      x: A.x + (e1.x - A.x) / (1 - t),\n      y: A.y + (e1.y - A.y) / (1 - t)\n    },\n        v2 = {\n      x: A.x + (e2.x - A.x) / t,\n      y: A.y + (e2.y - A.y) / t\n    },\n        nc1 = {\n      x: S.x + (v1.x - S.x) / t,\n      y: S.y + (v1.y - S.y) / t\n    },\n        nc2 = {\n      x: E.x + (v2.x - E.x) / (1 - t),\n      y: E.y + (v2.y - E.y) / (1 - t)\n    }; // ...done\n\n    return new Bezier(S, nc1, nc2, E);\n  };\n\n  var getUtils = function () {\n    return utils;\n  };\n\n  Bezier.getUtils = getUtils;\n  Bezier.PolyBezier = PolyBezier;\n  Bezier.prototype = {\n    getUtils: getUtils,\n    valueOf: function () {\n      return this.toString();\n    },\n    toString: function () {\n      return utils.pointsToString(this.points);\n    },\n    toSVG: function (relative) {\n      if (this._3d) return false;\n      var p = this.points,\n          x = p[0].x,\n          y = p[0].y,\n          s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n\n      for (var i = 1, last = p.length; i < last; i++) {\n        s.push(p[i].x);\n        s.push(p[i].y);\n      }\n\n      return s.join(\" \");\n    },\n    setRatios: function (ratios) {\n      if (ratios.length !== this.points.length) {\n        throw new Error(\"incorrect number of ratio values\");\n      }\n\n      this.ratios = ratios;\n      this._lut = []; //  invalidate any precomputed LUT\n    },\n    verify: function () {\n      var print = this.coordDigest();\n\n      if (print !== this._print) {\n        this._print = print;\n        this.update();\n      }\n    },\n    coordDigest: function () {\n      return this.points.map(function (c, pos) {\n        return '' + pos + c.x + c.y + (c.z ? c.z : 0);\n      }).join('');\n    },\n    update: function (newprint) {\n      // invalidate any precomputed LUT\n      this._lut = [];\n      this.dpoints = utils.derive(this.points, this._3d);\n      this.computedirection();\n    },\n    computedirection: function () {\n      var points = this.points;\n      var angle = utils.angle(points[0], points[this.order], points[1]);\n      this.clockwise = angle > 0;\n    },\n    length: function () {\n      return utils.length(this.derivative.bind(this));\n    },\n    _lut: [],\n    getLUT: function (steps) {\n      this.verify();\n      steps = steps || 100;\n\n      if (this._lut.length === steps) {\n        return this._lut;\n      }\n\n      this._lut = []; // We want a range from 0 to 1 inclusive, so\n      // we decrement and then use <= rather than <:\n\n      steps--;\n\n      for (var t = 0; t <= steps; t++) {\n        this._lut.push(this.compute(t / steps));\n      }\n\n      return this._lut;\n    },\n    on: function (point, error) {\n      error = error || 5;\n      var lut = this.getLUT(),\n          hits = [],\n          c,\n          t = 0;\n\n      for (var i = 0; i < lut.length; i++) {\n        c = lut[i];\n\n        if (utils.dist(c, point) < error) {\n          hits.push(c);\n          t += i / lut.length;\n        }\n      }\n\n      if (!hits.length) return false;\n      return t /= hits.length;\n    },\n    project: function (point) {\n      // step 1: coarse check\n      var LUT = this.getLUT(),\n          l = LUT.length - 1,\n          closest = utils.closest(LUT, point),\n          mdist = closest.mdist,\n          mpos = closest.mpos; // step 2: fine check\n\n      var ft,\n          t,\n          p,\n          d,\n          t1 = (mpos - 1) / l,\n          t2 = (mpos + 1) / l,\n          step = 0.1 / l;\n      mdist += 1;\n\n      for (t = t1, ft = t; t < t2 + step; t += step) {\n        p = this.compute(t);\n        d = utils.dist(point, p);\n\n        if (d < mdist) {\n          mdist = d;\n          ft = t;\n        }\n      }\n\n      p = this.compute(ft);\n      p.t = ft;\n      p.d = mdist;\n      return p;\n    },\n    get: function (t) {\n      return this.compute(t);\n    },\n    point: function (idx) {\n      return this.points[idx];\n    },\n    compute: function (t) {\n      if (this.ratios) return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n      return utils.compute(t, this.points, this._3d, this.ratios);\n    },\n    raise: function () {\n      var p = this.points,\n          np = [p[0]],\n          i,\n          k = p.length,\n          pi,\n          pim;\n\n      for (var i = 1; i < k; i++) {\n        pi = p[i];\n        pim = p[i - 1];\n        np[i] = {\n          x: (k - i) / k * pi.x + i / k * pim.x,\n          y: (k - i) / k * pi.y + i / k * pim.y\n        };\n      }\n\n      np[k] = p[k - 1];\n      return new Bezier(np);\n    },\n    derivative: function (t) {\n      var mt = 1 - t,\n          a,\n          b,\n          c = 0,\n          p = this.dpoints[0];\n\n      if (this.order === 2) {\n        p = [p[0], p[1], ZERO];\n        a = mt;\n        b = t;\n      }\n\n      if (this.order === 3) {\n        a = mt * mt;\n        b = mt * t * 2;\n        c = t * t;\n      }\n\n      var ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y\n      };\n\n      if (this._3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z;\n      }\n\n      return ret;\n    },\n    curvature: function (t) {\n      return utils.curvature(t, this.points, this._3d);\n    },\n    inflections: function () {\n      return utils.inflections(this.points);\n    },\n    normal: function (t) {\n      return this._3d ? this.__normal3(t) : this.__normal2(t);\n    },\n    __normal2: function (t) {\n      var d = this.derivative(t);\n      var q = sqrt(d.x * d.x + d.y * d.y);\n      return {\n        x: -d.y / q,\n        y: d.x / q\n      };\n    },\n    __normal3: function (t) {\n      // see http://stackoverflow.com/questions/25453159\n      var r1 = this.derivative(t),\n          r2 = this.derivative(t + 0.01),\n          q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n          q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n      r1.x /= q1;\n      r1.y /= q1;\n      r1.z /= q1;\n      r2.x /= q2;\n      r2.y /= q2;\n      r2.z /= q2; // cross product\n\n      var c = {\n        x: r2.y * r1.z - r2.z * r1.y,\n        y: r2.z * r1.x - r2.x * r1.z,\n        z: r2.x * r1.y - r2.y * r1.x\n      };\n      var m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n      c.x /= m;\n      c.y /= m;\n      c.z /= m; // rotation matrix\n\n      var R = [c.x * c.x, c.x * c.y - c.z, c.x * c.z + c.y, c.x * c.y + c.z, c.y * c.y, c.y * c.z - c.x, c.x * c.z - c.y, c.y * c.z + c.x, c.z * c.z]; // normal vector:\n\n      var n = {\n        x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n        y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n        z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z\n      };\n      return n;\n    },\n    hull: function (t) {\n      var p = this.points,\n          _p = [],\n          pt,\n          q = [],\n          idx = 0,\n          i = 0,\n          l = 0;\n      q[idx++] = p[0];\n      q[idx++] = p[1];\n      q[idx++] = p[2];\n\n      if (this.order === 3) {\n        q[idx++] = p[3];\n      } // we lerp between all points at each iteration, until we have 1 point left.\n\n\n      while (p.length > 1) {\n        _p = [];\n\n        for (i = 0, l = p.length - 1; i < l; i++) {\n          pt = utils.lerp(t, p[i], p[i + 1]);\n          q[idx++] = pt;\n\n          _p.push(pt);\n        }\n\n        p = _p;\n      }\n\n      return q;\n    },\n    split: function (t1, t2) {\n      // shortcuts\n      if (t1 === 0 && !!t2) {\n        return this.split(t2).left;\n      }\n\n      if (t2 === 1) {\n        return this.split(t1).right;\n      } // no shortcut: use \"de Casteljau\" iteration.\n\n\n      var q = this.hull(t1);\n      var result = {\n        left: this.order === 2 ? new Bezier([q[0], q[3], q[5]]) : new Bezier([q[0], q[4], q[7], q[9]]),\n        right: this.order === 2 ? new Bezier([q[5], q[4], q[2]]) : new Bezier([q[9], q[8], q[6], q[3]]),\n        span: q\n      }; // make sure we bind _t1/_t2 information!\n\n      result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n      result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n      result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n      result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2); // if we have no t2, we're done\n\n      if (!t2) {\n        return result;\n      } // if we have a t2, split again:\n\n\n      t2 = utils.map(t2, t1, 1, 0, 1);\n      var subsplit = result.right.split(t2);\n      return subsplit.left;\n    },\n    extrema: function () {\n      var dims = this.dims,\n          result = {},\n          roots = [],\n          p,\n          mfn;\n      dims.forEach(function (dim) {\n        mfn = function (v) {\n          return v[dim];\n        };\n\n        p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this));\n      roots = roots.sort(utils.numberSort).filter(function (v, idx) {\n        return roots.indexOf(v) === idx;\n      });\n      result.values = roots;\n      return result;\n    },\n    bbox: function () {\n      var extrema = this.extrema(),\n          result = {};\n      this.dims.forEach(function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this));\n      return result;\n    },\n    overlaps: function (curve) {\n      var lbbox = this.bbox(),\n          tbbox = curve.bbox();\n      return utils.bboxoverlap(lbbox, tbbox);\n    },\n    offset: function (t, d) {\n      if (typeof d !== \"undefined\") {\n        var c = this.get(t);\n        var n = this.normal(t);\n        var ret = {\n          c: c,\n          n: n,\n          x: c.x + n.x * d,\n          y: c.y + n.y * d\n        };\n\n        if (this._3d) {\n          ret.z = c.z + n.z * d;\n        }\n\n        return ret;\n      }\n\n      if (this._linear) {\n        var nv = this.normal(0);\n        var coords = this.points.map(function (p) {\n          var ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y\n          };\n\n          if (p.z && n.z) {\n            ret.z = p.z + t * nv.z;\n          }\n\n          return ret;\n        });\n        return [new Bezier(coords)];\n      }\n\n      var reduced = this.reduce();\n      return reduced.map(function (s) {\n        if (s._linear) {\n          return s.offset(t)[0];\n        }\n\n        return s.scale(t);\n      });\n    },\n    simple: function () {\n      if (this.order === 3) {\n        var a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n        var a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n        if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return false;\n      }\n\n      var n1 = this.normal(0);\n      var n2 = this.normal(1);\n      var s = n1.x * n2.x + n1.y * n2.y;\n\n      if (this._3d) {\n        s += n1.z * n2.z;\n      }\n\n      var angle = abs(acos(s));\n      return angle < pi / 3;\n    },\n    reduce: function () {\n      var i,\n          t1 = 0,\n          t2 = 0,\n          step = 0.01,\n          segment,\n          pass1 = [],\n          pass2 = []; // first pass: split on extrema\n\n      var extrema = this.extrema().values;\n\n      if (extrema.indexOf(0) === -1) {\n        extrema = [0].concat(extrema);\n      }\n\n      if (extrema.indexOf(1) === -1) {\n        extrema.push(1);\n      }\n\n      for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n        t2 = extrema[i];\n        segment = this.split(t1, t2);\n        segment._t1 = t1;\n        segment._t2 = t2;\n        pass1.push(segment);\n        t1 = t2;\n      } // second pass: further reduce these segments to simple segments\n\n\n      pass1.forEach(function (p1) {\n        t1 = 0;\n        t2 = 0;\n\n        while (t2 <= 1) {\n          for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n            segment = p1.split(t1, t2);\n\n            if (!segment.simple()) {\n              t2 -= step;\n\n              if (abs(t1 - t2) < step) {\n                // we can never form a reduction\n                return [];\n              }\n\n              segment = p1.split(t1, t2);\n              segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n              segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n              pass2.push(segment);\n              t1 = t2;\n              break;\n            }\n          }\n        }\n\n        if (t1 < 1) {\n          segment = p1.split(t1, 1);\n          segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n          segment._t2 = p1._t2;\n          pass2.push(segment);\n        }\n      });\n      return pass2;\n    },\n    scale: function (d) {\n      var order = this.order;\n      var distanceFn = false;\n\n      if (typeof d === \"function\") {\n        distanceFn = d;\n      }\n\n      if (distanceFn && order === 2) {\n        return this.raise().scale(distanceFn);\n      } // TODO: add special handling for degenerate (=linear) curves.\n\n\n      var clockwise = this.clockwise;\n      var r1 = distanceFn ? distanceFn(0) : d;\n      var r2 = distanceFn ? distanceFn(1) : d;\n      var v = [this.offset(0, 10), this.offset(1, 10)];\n      var o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n      if (!o) {\n        throw new Error(\"cannot scale this curve. Try reducing it first.\");\n      } // move all points by distance 'd' wrt the origin 'o'\n\n\n      var points = this.points,\n          np = []; // move end points by fixed distance along normal.\n\n      [0, 1].forEach(function (t) {\n        var p = np[t * order] = utils.copy(points[t * order]);\n        p.x += (t ? r2 : r1) * v[t].n.x;\n        p.y += (t ? r2 : r1) * v[t].n.y;\n      }.bind(this));\n\n      if (!distanceFn) {\n        // move control points to lie on the intersection of the offset\n        // derivative vector, and the origin-through-control vector\n        [0, 1].forEach(function (t) {\n          if (this.order === 2 && !!t) return;\n          var p = np[t * order];\n          var d = this.derivative(t);\n          var p2 = {\n            x: p.x + d.x,\n            y: p.y + d.y\n          };\n          np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n        }.bind(this));\n        return new Bezier(np);\n      } // move control points by \"however much necessary to\n      // ensure the correct tangent to endpoint\".\n\n\n      [0, 1].forEach(function (t) {\n        if (this.order === 2 && !!t) return;\n        var p = points[t + 1];\n        var ov = {\n          x: p.x - o.x,\n          y: p.y - o.y\n        };\n        var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n        if (distanceFn && !clockwise) rc = -rc;\n        var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n        ov.x /= m;\n        ov.y /= m;\n        np[t + 1] = {\n          x: p.x + rc * ov.x,\n          y: p.y + rc * ov.y\n        };\n      }.bind(this));\n      return new Bezier(np);\n    },\n    outline: function (d1, d2, d3, d4) {\n      d2 = typeof d2 === \"undefined\" ? d1 : d2;\n      var reduced = this.reduce(),\n          len = reduced.length,\n          fcurves = [],\n          bcurves = [],\n          p,\n          alen = 0,\n          tlen = this.length();\n      var graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n      function linearDistanceFunction(s, e, tlen, alen, slen) {\n        return function (v) {\n          var f1 = alen / tlen,\n              f2 = (alen + slen) / tlen,\n              d = e - s;\n          return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n        };\n      } // form curve oulines\n\n\n      reduced.forEach(function (segment) {\n        slen = segment.length();\n\n        if (graduated) {\n          fcurves.push(segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen)));\n          bcurves.push(segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen)));\n        } else {\n          fcurves.push(segment.scale(d1));\n          bcurves.push(segment.scale(-d2));\n        }\n\n        alen += slen;\n      }); // reverse the \"return\" outline\n\n      bcurves = bcurves.map(function (s) {\n        p = s.points;\n\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n\n        return s;\n      }).reverse(); // form the endcaps as lines\n\n      var fs = fcurves[0].points[0],\n          fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n          bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n          be = bcurves[0].points[0],\n          ls = utils.makeline(bs, fs),\n          le = utils.makeline(fe, be),\n          segments = [ls].concat(fcurves).concat([le]).concat(bcurves),\n          slen = segments.length;\n      return new PolyBezier(segments);\n    },\n    outlineshapes: function (d1, d2, curveIntersectionThreshold) {\n      d2 = d2 || d1;\n      var outline = this.outline(d1, d2).curves;\n      var shapes = [];\n\n      for (var i = 1, len = outline.length; i < len / 2; i++) {\n        var shape = utils.makeshape(outline[i], outline[len - i], curveIntersectionThreshold);\n        shape.startcap.virtual = i > 1;\n        shape.endcap.virtual = i < len / 2 - 1;\n        shapes.push(shape);\n      }\n\n      return shapes;\n    },\n    intersects: function (curve, curveIntersectionThreshold) {\n      if (!curve) return this.selfintersects(curveIntersectionThreshold);\n\n      if (curve.p1 && curve.p2) {\n        return this.lineIntersects(curve);\n      }\n\n      if (curve instanceof Bezier) {\n        curve = curve.reduce();\n      }\n\n      return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);\n    },\n    lineIntersects: function (line) {\n      var mx = min(line.p1.x, line.p2.x),\n          my = min(line.p1.y, line.p2.y),\n          MX = max(line.p1.x, line.p2.x),\n          MY = max(line.p1.y, line.p2.y),\n          self = this;\n      return utils.roots(this.points, line).filter(function (t) {\n        var p = self.get(t);\n        return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n      });\n    },\n    selfintersects: function (curveIntersectionThreshold) {\n      var reduced = this.reduce(); // \"simple\" curves cannot intersect with their direct\n      // neighbour, so for each segment X we check whether\n      // it intersects [0:x-2][x+2:last].\n\n      var i,\n          len = reduced.length - 2,\n          results = [],\n          result,\n          left,\n          right;\n\n      for (i = 0; i < len; i++) {\n        left = reduced.slice(i, i + 1);\n        right = reduced.slice(i + 2);\n        result = this.curveintersects(left, right, curveIntersectionThreshold);\n        results = results.concat(result);\n      }\n\n      return results;\n    },\n    curveintersects: function (c1, c2, curveIntersectionThreshold) {\n      var pairs = []; // step 1: pair off any overlapping segments\n\n      c1.forEach(function (l) {\n        c2.forEach(function (r) {\n          if (l.overlaps(r)) {\n            pairs.push({\n              left: l,\n              right: r\n            });\n          }\n        });\n      }); // step 2: for each pairing, run through the convergence algorithm.\n\n      var intersections = [];\n      pairs.forEach(function (pair) {\n        var result = utils.pairiteration(pair.left, pair.right, curveIntersectionThreshold);\n\n        if (result.length > 0) {\n          intersections = intersections.concat(result);\n        }\n      });\n      return intersections;\n    },\n    arcs: function (errorThreshold) {\n      errorThreshold = errorThreshold || 0.5;\n      var circles = [];\n      return this._iterate(errorThreshold, circles);\n    },\n    _error: function (pc, np1, s, e) {\n      var q = (e - s) / 4,\n          c1 = this.get(s + q),\n          c2 = this.get(e - q),\n          ref = utils.dist(pc, np1),\n          d1 = utils.dist(pc, c1),\n          d2 = utils.dist(pc, c2);\n      return abs(d1 - ref) + abs(d2 - ref);\n    },\n    _iterate: function (errorThreshold, circles) {\n      var t_s = 0,\n          t_e = 1,\n          safety; // we do a binary search to find the \"good `t` closest to no-longer-good\"\n\n      do {\n        safety = 0; // step 1: start with the maximum possible arc\n\n        t_e = 1; // points:\n\n        var np1 = this.get(t_s),\n            np2,\n            np3,\n            arc,\n            prev_arc; // booleans:\n\n        var curr_good = false,\n            prev_good = false,\n            done; // numbers:\n\n        var t_m = t_e,\n            prev_e = 1,\n            step = 0; // step 2: find the best possible arc\n\n        do {\n          prev_good = curr_good;\n          prev_arc = arc;\n          t_m = (t_s + t_e) / 2;\n          step++;\n          np2 = this.get(t_m);\n          np3 = this.get(t_e);\n          arc = utils.getccenter(np1, np2, np3); //also save the t values\n\n          arc.interval = {\n            start: t_s,\n            end: t_e\n          };\n\n          var error = this._error(arc, np1, t_s, t_e);\n\n          curr_good = error <= errorThreshold;\n          done = prev_good && !curr_good;\n          if (!done) prev_e = t_e; // this arc is fine: we can move 'e' up to see if we can find a wider arc\n\n          if (curr_good) {\n            // if e is already at max, then we're done for this arc.\n            if (t_e >= 1) {\n              // make sure we cap at t=1\n              arc.interval.end = prev_e = 1;\n              prev_arc = arc; // if we capped the arc segment to t=1 we also need to make sure that\n              // the arc's end angle is correct with respect to the bezier end point.\n\n              if (t_e > 1) {\n                var d = {\n                  x: arc.x + arc.r * cos(arc.e),\n                  y: arc.y + arc.r * sin(arc.e)\n                };\n                arc.e += utils.angle({\n                  x: arc.x,\n                  y: arc.y\n                }, d, this.get(1));\n              }\n\n              break;\n            } // if not, move it up by half the iteration distance\n\n\n            t_e = t_e + (t_e - t_s) / 2;\n          } else {\n            // this is a bad arc: we need to move 'e' down to find a good arc\n            t_e = t_m;\n          }\n        } while (!done && safety++ < 100);\n\n        if (safety >= 100) {\n          break;\n        } // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n\n        prev_arc = prev_arc ? prev_arc : arc;\n        circles.push(prev_arc);\n        t_s = prev_e;\n      } while (t_e < 1);\n\n      return circles;\n    }\n  };\n  module.exports = Bezier;\n})();","map":{"version":3,"sources":["/Users/maclaptop/Documents/GitHub/ashokpandey.com/node_modules/bezier-js/lib/bezier.js"],"names":["abs","Math","min","max","cos","sin","acos","sqrt","pi","PI","ZERO","x","y","z","utils","require","PolyBezier","Bezier","coords","args","forEach","slice","call","arguments","coordlen","length","newargs","point","d","push","higher","len","Error","_3d","points","idx","step","order","dims","dimlen","curve","a","align","p1","p2","i","_linear","_t1","_t2","update","svgToBeziers","SVGtoBeziers","getABC","n","S","B","E","t","u","projectionratio","um","C","s","abcratio","A","quadraticFromPoints","p3","abc","cubicFromPoints","d1","dist","d2","selen","lx","ly","bx1","by1","bx2","by2","e1","e2","v1","v2","nc1","nc2","getUtils","prototype","valueOf","toString","pointsToString","toSVG","relative","p","last","join","setRatios","ratios","_lut","verify","print","coordDigest","_print","map","c","pos","newprint","dpoints","derive","computedirection","angle","clockwise","derivative","bind","getLUT","steps","compute","on","error","lut","hits","project","LUT","l","closest","mdist","mpos","ft","t1","t2","get","computeWithRatios","raise","np","k","pim","mt","b","ret","curvature","inflections","normal","__normal3","__normal2","q","r1","r2","q1","q2","m","R","hull","_p","pt","lerp","split","left","right","result","span","subsplit","extrema","roots","mfn","dim","v","droots","concat","filter","sort","numberSort","indexOf","values","bbox","getminmax","overlaps","lbbox","tbbox","bboxoverlap","offset","nv","reduced","reduce","scale","simple","a1","a2","n1","n2","segment","pass1","pass2","distanceFn","o","lli4","copy","ov","rc","outline","d3","d4","fcurves","bcurves","alen","tlen","graduated","linearDistanceFunction","e","slen","f1","f2","reverse","fs","fe","bs","be","ls","makeline","le","segments","outlineshapes","curveIntersectionThreshold","curves","shapes","shape","makeshape","startcap","virtual","endcap","intersects","selfintersects","lineIntersects","curveintersects","line","mx","my","MX","MY","self","between","results","c1","c2","pairs","r","intersections","pair","pairiteration","arcs","errorThreshold","circles","_iterate","_error","pc","np1","ref","t_s","t_e","safety","np2","np3","arc","prev_arc","curr_good","prev_good","done","t_m","prev_e","getccenter","interval","start","end","module","exports"],"mappings":"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","sourcesContent":["/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n(function() {\n  \"use strict\";\n\n  // math-inlining.\n  var abs = Math.abs,\n    min = Math.min,\n    max = Math.max,\n    cos = Math.cos,\n    sin = Math.sin,\n    acos = Math.acos,\n    sqrt = Math.sqrt,\n    pi = Math.PI,\n    // a zero coordinate, which is surprisingly useful\n    ZERO = { x: 0, y: 0, z: 0 };\n\n  // quite needed\n  var utils = require(\"./utils.js\");\n\n  // only used for outlines atm.\n  var PolyBezier = require(\"./poly-bezier.js\");\n\n  /**\n   * Bezier curve constructor. The constructor argument can be one of three things:\n   *\n   * 1. array/4 of {x:..., y:..., z:...}, z optional\n   * 2. numerical array/8 ordered x1,y1,x2,y2,x3,y3,x4,y4\n   * 3. numerical array/12 ordered x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4\n   *\n   */\n  var Bezier = function(coords) {\n    var args = coords && coords.forEach ? coords : [].slice.call(arguments);\n    var coordlen = false;\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      var newargs = [];\n      args.forEach(function(point) {\n        [\"x\", \"y\", \"z\"].forEach(function(d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n    var higher = false;\n    var len = args.length;\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n    var _3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\");\n    this._3d = _3d;\n    var points = [];\n    for (var idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1]\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    this.order = points.length - 1;\n    this.points = points;\n    var dims = [\"x\", \"y\"];\n    if (_3d) dims.push(\"z\");\n    this.dims = dims;\n    this.dimlen = dims.length;\n\n    (function(curve) {\n      var order = curve.order;\n      var points = curve.points;\n      var a = utils.align(points, { p1: points[0], p2: points[order] });\n      for (var i = 0; i < a.length; i++) {\n        if (abs(a[i].y) > 0.0001) {\n          curve._linear = false;\n          return;\n        }\n      }\n      curve._linear = true;\n    })(this);\n\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  };\n\n  var svgToBeziers = require(\"./svg-to-beziers\");\n\n  /**\n   * turn an svg <path> d attribute into a sequence of Bezier segments.\n   */\n  Bezier.SVGtoBeziers = function(d) {\n    return svgToBeziers(Bezier, d);\n  };\n\n  function getABC(n, S, B, E, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    var u = utils.projectionratio(t, n),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y\n      },\n      s = utils.abcratio(t, n),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s\n      };\n    return { A: A, B: B, C: C };\n  }\n\n  Bezier.quadraticFromPoints = function(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    var abc = getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  };\n\n  Bezier.cubicFromPoints = function(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    var abc = getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    var d2 = d1 * (1 - t) / t;\n\n    var selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    var e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t)\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  };\n\n  var getUtils = function() {\n    return utils;\n  };\n\n  Bezier.getUtils = getUtils;\n\n  Bezier.PolyBezier = PolyBezier;\n\n  Bezier.prototype = {\n    getUtils: getUtils,\n    valueOf: function() {\n      return this.toString();\n    },\n    toString: function() {\n      return utils.pointsToString(this.points);\n    },\n    toSVG: function(relative) {\n      if (this._3d) return false;\n      var p = this.points,\n        x = p[0].x,\n        y = p[0].y,\n        s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n      for (var i = 1, last = p.length; i < last; i++) {\n        s.push(p[i].x);\n        s.push(p[i].y);\n      }\n      return s.join(\" \");\n    },\n    setRatios: function(ratios) {\n      if (ratios.length !== this.points.length) {\n        throw new Error(\"incorrect number of ratio values\");\n      }\n      this.ratios = ratios;\n      this._lut = []; //  invalidate any precomputed LUT\n    },\n    verify: function() {\n      var print = this.coordDigest();\n      if (print !== this._print) {\n        this._print = print;\n        this.update();\n      }\n    },\n    coordDigest: function() {\n      return this.points.map(function(c,pos) {\n        return '' + pos + c.x + c.y + (c.z?c.z:0);\n      }).join('');\n    },\n    update: function(newprint) {\n      // invalidate any precomputed LUT\n      this._lut = [];\n      this.dpoints = utils.derive(this.points, this._3d);\n      this.computedirection();\n    },\n    computedirection: function() {\n      var points = this.points;\n      var angle = utils.angle(points[0], points[this.order], points[1]);\n      this.clockwise = angle > 0;\n    },\n    length: function() {\n      return utils.length(this.derivative.bind(this));\n    },\n    _lut: [],\n    getLUT: function(steps) {\n      this.verify();\n      steps = steps || 100;\n      if (this._lut.length === steps) {\n        return this._lut;\n      }\n      this._lut = [];\n      // We want a range from 0 to 1 inclusive, so\n      // we decrement and then use <= rather than <:\n      steps--;\n      for (var t = 0; t <= steps; t++) {\n        this._lut.push(this.compute(t / steps));\n      }\n      return this._lut;\n    },\n    on: function(point, error) {\n      error = error || 5;\n      var lut = this.getLUT(),\n        hits = [],\n        c,\n        t = 0;\n      for (var i = 0; i < lut.length; i++) {\n        c = lut[i];\n        if (utils.dist(c, point) < error) {\n          hits.push(c);\n          t += i / lut.length;\n        }\n      }\n      if (!hits.length) return false;\n      return (t /= hits.length);\n    },\n    project: function(point) {\n      // step 1: coarse check\n      var LUT = this.getLUT(),\n        l = LUT.length - 1,\n        closest = utils.closest(LUT, point),\n        mdist = closest.mdist,\n        mpos = closest.mpos;\n\n      // step 2: fine check\n      var ft,\n        t,\n        p,\n        d,\n        t1 = (mpos - 1) / l,\n        t2 = (mpos + 1) / l,\n        step = 0.1 / l;\n      mdist += 1;\n      for (t = t1, ft = t; t < t2 + step; t += step) {\n        p = this.compute(t);\n        d = utils.dist(point, p);\n        if (d < mdist) {\n          mdist = d;\n          ft = t;\n        }\n      }\n      p = this.compute(ft);\n      p.t = ft;\n      p.d = mdist;\n      return p;\n    },\n    get: function(t) {\n      return this.compute(t);\n    },\n    point: function(idx) {\n      return this.points[idx];\n    },\n    compute: function(t) {\n      if (this.ratios) return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n      return utils.compute(t, this.points, this._3d, this.ratios);\n    },\n    raise: function() {\n      var p = this.points,\n        np = [p[0]],\n        i,\n        k = p.length,\n        pi,\n        pim;\n      for (var i = 1; i < k; i++) {\n        pi = p[i];\n        pim = p[i - 1];\n        np[i] = {\n          x: (k - i) / k * pi.x + i / k * pim.x,\n          y: (k - i) / k * pi.y + i / k * pim.y\n        };\n      }\n      np[k] = p[k - 1];\n      return new Bezier(np);\n    },\n    derivative: function(t) {\n      var mt = 1 - t,\n        a,\n        b,\n        c = 0,\n        p = this.dpoints[0];\n      if (this.order === 2) {\n        p = [p[0], p[1], ZERO];\n        a = mt;\n        b = t;\n      }\n      if (this.order === 3) {\n        a = mt * mt;\n        b = mt * t * 2;\n        c = t * t;\n      }\n      var ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y\n      };\n      if (this._3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z;\n      }\n      return ret;\n    },\n    curvature: function(t) {\n      return utils.curvature(t, this.points, this._3d);\n    },\n    inflections: function() {\n      return utils.inflections(this.points);\n    },\n    normal: function(t) {\n      return this._3d ? this.__normal3(t) : this.__normal2(t);\n    },\n    __normal2: function(t) {\n      var d = this.derivative(t);\n      var q = sqrt(d.x * d.x + d.y * d.y);\n      return { x: -d.y / q, y: d.x / q };\n    },\n    __normal3: function(t) {\n      // see http://stackoverflow.com/questions/25453159\n      var r1 = this.derivative(t),\n        r2 = this.derivative(t + 0.01),\n        q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n        q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n      r1.x /= q1;\n      r1.y /= q1;\n      r1.z /= q1;\n      r2.x /= q2;\n      r2.y /= q2;\n      r2.z /= q2;\n      // cross product\n      var c = {\n        x: r2.y * r1.z - r2.z * r1.y,\n        y: r2.z * r1.x - r2.x * r1.z,\n        z: r2.x * r1.y - r2.y * r1.x\n      };\n      var m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n      c.x /= m;\n      c.y /= m;\n      c.z /= m;\n      // rotation matrix\n      var R = [\n        c.x * c.x,\n        c.x * c.y - c.z,\n        c.x * c.z + c.y,\n        c.x * c.y + c.z,\n        c.y * c.y,\n        c.y * c.z - c.x,\n        c.x * c.z - c.y,\n        c.y * c.z + c.x,\n        c.z * c.z\n      ];\n      // normal vector:\n      var n = {\n        x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n        y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n        z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z\n      };\n      return n;\n    },\n    hull: function(t) {\n      var p = this.points,\n        _p = [],\n        pt,\n        q = [],\n        idx = 0,\n        i = 0,\n        l = 0;\n      q[idx++] = p[0];\n      q[idx++] = p[1];\n      q[idx++] = p[2];\n      if (this.order === 3) {\n        q[idx++] = p[3];\n      }\n      // we lerp between all points at each iteration, until we have 1 point left.\n      while (p.length > 1) {\n        _p = [];\n        for (i = 0, l = p.length - 1; i < l; i++) {\n          pt = utils.lerp(t, p[i], p[i + 1]);\n          q[idx++] = pt;\n          _p.push(pt);\n        }\n        p = _p;\n      }\n      return q;\n    },\n    split: function(t1, t2) {\n      // shortcuts\n      if (t1 === 0 && !!t2) {\n        return this.split(t2).left;\n      }\n      if (t2 === 1) {\n        return this.split(t1).right;\n      }\n\n      // no shortcut: use \"de Casteljau\" iteration.\n      var q = this.hull(t1);\n      var result = {\n        left:\n          this.order === 2\n            ? new Bezier([q[0], q[3], q[5]])\n            : new Bezier([q[0], q[4], q[7], q[9]]),\n        right:\n          this.order === 2\n            ? new Bezier([q[5], q[4], q[2]])\n            : new Bezier([q[9], q[8], q[6], q[3]]),\n        span: q\n      };\n\n      // make sure we bind _t1/_t2 information!\n      result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n      result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n      result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n      result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n      // if we have no t2, we're done\n      if (!t2) {\n        return result;\n      }\n\n      // if we have a t2, split again:\n      t2 = utils.map(t2, t1, 1, 0, 1);\n      var subsplit = result.right.split(t2);\n      return subsplit.left;\n    },\n    extrema: function() {\n      var dims = this.dims,\n        result = {},\n        roots = [],\n        p,\n        mfn;\n      dims.forEach(\n        function(dim) {\n          mfn = function(v) {\n            return v[dim];\n          };\n          p = this.dpoints[0].map(mfn);\n          result[dim] = utils.droots(p);\n          if (this.order === 3) {\n            p = this.dpoints[1].map(mfn);\n            result[dim] = result[dim].concat(utils.droots(p));\n          }\n          result[dim] = result[dim].filter(function(t) {\n            return t >= 0 && t <= 1;\n          });\n          roots = roots.concat(result[dim].sort(utils.numberSort));\n        }.bind(this)\n      );\n      roots = roots.sort(utils.numberSort).filter(function(v, idx) {\n        return roots.indexOf(v) === idx;\n      });\n      result.values = roots;\n      return result;\n    },\n    bbox: function() {\n      var extrema = this.extrema(),\n        result = {};\n      this.dims.forEach(\n        function(d) {\n          result[d] = utils.getminmax(this, d, extrema[d]);\n        }.bind(this)\n      );\n      return result;\n    },\n    overlaps: function(curve) {\n      var lbbox = this.bbox(),\n        tbbox = curve.bbox();\n      return utils.bboxoverlap(lbbox, tbbox);\n    },\n    offset: function(t, d) {\n      if (typeof d !== \"undefined\") {\n        var c = this.get(t);\n        var n = this.normal(t);\n        var ret = {\n          c: c,\n          n: n,\n          x: c.x + n.x * d,\n          y: c.y + n.y * d\n        };\n        if (this._3d) {\n          ret.z = c.z + n.z * d;\n        }\n        return ret;\n      }\n      if (this._linear) {\n        var nv = this.normal(0);\n        var coords = this.points.map(function(p) {\n          var ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y\n          };\n          if (p.z && n.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n        return [new Bezier(coords)];\n      }\n      var reduced = this.reduce();\n      return reduced.map(function(s) {\n        if (s._linear) {\n          return s.offset(t)[0];\n        }\n        return s.scale(t);\n      });\n    },\n    simple: function() {\n      if (this.order === 3) {\n        var a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n        var a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n        if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n      }\n      var n1 = this.normal(0);\n      var n2 = this.normal(1);\n      var s = n1.x * n2.x + n1.y * n2.y;\n      if (this._3d) {\n        s += n1.z * n2.z;\n      }\n      var angle = abs(acos(s));\n      return angle < pi / 3;\n    },\n    reduce: function() {\n      var i,\n        t1 = 0,\n        t2 = 0,\n        step = 0.01,\n        segment,\n        pass1 = [],\n        pass2 = [];\n      // first pass: split on extrema\n      var extrema = this.extrema().values;\n      if (extrema.indexOf(0) === -1) {\n        extrema = [0].concat(extrema);\n      }\n      if (extrema.indexOf(1) === -1) {\n        extrema.push(1);\n      }\n\n      for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n        t2 = extrema[i];\n        segment = this.split(t1, t2);\n        segment._t1 = t1;\n        segment._t2 = t2;\n        pass1.push(segment);\n        t1 = t2;\n      }\n\n      // second pass: further reduce these segments to simple segments\n      pass1.forEach(function(p1) {\n        t1 = 0;\n        t2 = 0;\n        while (t2 <= 1) {\n          for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n            segment = p1.split(t1, t2);\n            if (!segment.simple()) {\n              t2 -= step;\n              if (abs(t1 - t2) < step) {\n                // we can never form a reduction\n                return [];\n              }\n              segment = p1.split(t1, t2);\n              segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n              segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n              pass2.push(segment);\n              t1 = t2;\n              break;\n            }\n          }\n        }\n        if (t1 < 1) {\n          segment = p1.split(t1, 1);\n          segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n          segment._t2 = p1._t2;\n          pass2.push(segment);\n        }\n      });\n      return pass2;\n    },\n    scale: function(d) {\n      var order = this.order;\n      var distanceFn = false;\n      if (typeof d === \"function\") {\n        distanceFn = d;\n      }\n      if (distanceFn && order === 2) {\n        return this.raise().scale(distanceFn);\n      }\n\n      // TODO: add special handling for degenerate (=linear) curves.\n      var clockwise = this.clockwise;\n      var r1 = distanceFn ? distanceFn(0) : d;\n      var r2 = distanceFn ? distanceFn(1) : d;\n      var v = [this.offset(0, 10), this.offset(1, 10)];\n      var o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n      if (!o) {\n        throw new Error(\"cannot scale this curve. Try reducing it first.\");\n      }\n      // move all points by distance 'd' wrt the origin 'o'\n      var points = this.points,\n        np = [];\n\n      // move end points by fixed distance along normal.\n      [0, 1].forEach(\n        function(t) {\n          var p = (np[t * order] = utils.copy(points[t * order]));\n          p.x += (t ? r2 : r1) * v[t].n.x;\n          p.y += (t ? r2 : r1) * v[t].n.y;\n        }.bind(this)\n      );\n\n      if (!distanceFn) {\n        // move control points to lie on the intersection of the offset\n        // derivative vector, and the origin-through-control vector\n        [0, 1].forEach(\n          function(t) {\n            if (this.order === 2 && !!t) return;\n            var p = np[t * order];\n            var d = this.derivative(t);\n            var p2 = { x: p.x + d.x, y: p.y + d.y };\n            np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n          }.bind(this)\n        );\n        return new Bezier(np);\n      }\n\n      // move control points by \"however much necessary to\n      // ensure the correct tangent to endpoint\".\n      [0, 1].forEach(\n        function(t) {\n          if (this.order === 2 && !!t) return;\n          var p = points[t + 1];\n          var ov = {\n            x: p.x - o.x,\n            y: p.y - o.y\n          };\n          var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n          if (distanceFn && !clockwise) rc = -rc;\n          var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n          ov.x /= m;\n          ov.y /= m;\n          np[t + 1] = {\n            x: p.x + rc * ov.x,\n            y: p.y + rc * ov.y\n          };\n        }.bind(this)\n      );\n      return new Bezier(np);\n    },\n    outline: function(d1, d2, d3, d4) {\n      d2 = typeof d2 === \"undefined\" ? d1 : d2;\n      var reduced = this.reduce(),\n        len = reduced.length,\n        fcurves = [],\n        bcurves = [],\n        p,\n        alen = 0,\n        tlen = this.length();\n\n      var graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n      function linearDistanceFunction(s, e, tlen, alen, slen) {\n        return function(v) {\n          var f1 = alen / tlen,\n            f2 = (alen + slen) / tlen,\n            d = e - s;\n          return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n        };\n      }\n\n      // form curve oulines\n      reduced.forEach(function(segment) {\n        slen = segment.length();\n        if (graduated) {\n          fcurves.push(\n            segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n          );\n          bcurves.push(\n            segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n          );\n        } else {\n          fcurves.push(segment.scale(d1));\n          bcurves.push(segment.scale(-d2));\n        }\n        alen += slen;\n      });\n\n      // reverse the \"return\" outline\n      bcurves = bcurves\n        .map(function(s) {\n          p = s.points;\n          if (p[3]) {\n            s.points = [p[3], p[2], p[1], p[0]];\n          } else {\n            s.points = [p[2], p[1], p[0]];\n          }\n          return s;\n        })\n        .reverse();\n\n      // form the endcaps as lines\n      var fs = fcurves[0].points[0],\n        fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n        bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n        be = bcurves[0].points[0],\n        ls = utils.makeline(bs, fs),\n        le = utils.makeline(fe, be),\n        segments = [ls]\n          .concat(fcurves)\n          .concat([le])\n          .concat(bcurves),\n        slen = segments.length;\n\n      return new PolyBezier(segments);\n    },\n    outlineshapes: function(d1, d2, curveIntersectionThreshold) {\n      d2 = d2 || d1;\n      var outline = this.outline(d1, d2).curves;\n      var shapes = [];\n      for (var i = 1, len = outline.length; i < len / 2; i++) {\n        var shape = utils.makeshape(\n          outline[i],\n          outline[len - i],\n          curveIntersectionThreshold\n        );\n        shape.startcap.virtual = i > 1;\n        shape.endcap.virtual = i < len / 2 - 1;\n        shapes.push(shape);\n      }\n      return shapes;\n    },\n    intersects: function(curve, curveIntersectionThreshold) {\n      if (!curve) return this.selfintersects(curveIntersectionThreshold);\n      if (curve.p1 && curve.p2) {\n        return this.lineIntersects(curve);\n      }\n      if (curve instanceof Bezier) {\n        curve = curve.reduce();\n      }\n      return this.curveintersects(\n        this.reduce(),\n        curve,\n        curveIntersectionThreshold\n      );\n    },\n    lineIntersects: function(line) {\n      var mx = min(line.p1.x, line.p2.x),\n        my = min(line.p1.y, line.p2.y),\n        MX = max(line.p1.x, line.p2.x),\n        MY = max(line.p1.y, line.p2.y),\n        self = this;\n      return utils.roots(this.points, line).filter(function(t) {\n        var p = self.get(t);\n        return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n      });\n    },\n    selfintersects: function(curveIntersectionThreshold) {\n      var reduced = this.reduce();\n      // \"simple\" curves cannot intersect with their direct\n      // neighbour, so for each segment X we check whether\n      // it intersects [0:x-2][x+2:last].\n      var i,\n        len = reduced.length - 2,\n        results = [],\n        result,\n        left,\n        right;\n      for (i = 0; i < len; i++) {\n        left = reduced.slice(i, i + 1);\n        right = reduced.slice(i + 2);\n        result = this.curveintersects(left, right, curveIntersectionThreshold);\n        results = results.concat(result);\n      }\n      return results;\n    },\n    curveintersects: function(c1, c2, curveIntersectionThreshold) {\n      var pairs = [];\n      // step 1: pair off any overlapping segments\n      c1.forEach(function(l) {\n        c2.forEach(function(r) {\n          if (l.overlaps(r)) {\n            pairs.push({ left: l, right: r });\n          }\n        });\n      });\n      // step 2: for each pairing, run through the convergence algorithm.\n      var intersections = [];\n      pairs.forEach(function(pair) {\n        var result = utils.pairiteration(\n          pair.left,\n          pair.right,\n          curveIntersectionThreshold\n        );\n        if (result.length > 0) {\n          intersections = intersections.concat(result);\n        }\n      });\n      return intersections;\n    },\n    arcs: function(errorThreshold) {\n      errorThreshold = errorThreshold || 0.5;\n      var circles = [];\n      return this._iterate(errorThreshold, circles);\n    },\n    _error: function(pc, np1, s, e) {\n      var q = (e - s) / 4,\n        c1 = this.get(s + q),\n        c2 = this.get(e - q),\n        ref = utils.dist(pc, np1),\n        d1 = utils.dist(pc, c1),\n        d2 = utils.dist(pc, c2);\n      return abs(d1 - ref) + abs(d2 - ref);\n    },\n    _iterate: function(errorThreshold, circles) {\n      var t_s = 0,\n        t_e = 1,\n        safety;\n      // we do a binary search to find the \"good `t` closest to no-longer-good\"\n      do {\n        safety = 0;\n\n        // step 1: start with the maximum possible arc\n        t_e = 1;\n\n        // points:\n        var np1 = this.get(t_s),\n          np2,\n          np3,\n          arc,\n          prev_arc;\n\n        // booleans:\n        var curr_good = false,\n          prev_good = false,\n          done;\n\n        // numbers:\n        var t_m = t_e,\n          prev_e = 1,\n          step = 0;\n\n        // step 2: find the best possible arc\n        do {\n          prev_good = curr_good;\n          prev_arc = arc;\n          t_m = (t_s + t_e) / 2;\n          step++;\n\n          np2 = this.get(t_m);\n          np3 = this.get(t_e);\n\n          arc = utils.getccenter(np1, np2, np3);\n\n          //also save the t values\n          arc.interval = {\n            start: t_s,\n            end: t_e\n          };\n\n          var error = this._error(arc, np1, t_s, t_e);\n          curr_good = error <= errorThreshold;\n\n          done = prev_good && !curr_good;\n          if (!done) prev_e = t_e;\n\n          // this arc is fine: we can move 'e' up to see if we can find a wider arc\n          if (curr_good) {\n            // if e is already at max, then we're done for this arc.\n            if (t_e >= 1) {\n              // make sure we cap at t=1\n              arc.interval.end = prev_e = 1;\n              prev_arc = arc;\n              // if we capped the arc segment to t=1 we also need to make sure that\n              // the arc's end angle is correct with respect to the bezier end point.\n              if (t_e > 1) {\n                var d = {\n                  x: arc.x + arc.r * cos(arc.e),\n                  y: arc.y + arc.r * sin(arc.e)\n                };\n                arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n              }\n              break;\n            }\n            // if not, move it up by half the iteration distance\n            t_e = t_e + (t_e - t_s) / 2;\n          } else {\n            // this is a bad arc: we need to move 'e' down to find a good arc\n            t_e = t_m;\n          }\n        } while (!done && safety++ < 100);\n\n        if (safety >= 100) {\n          break;\n        }\n\n        // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n        prev_arc = prev_arc ? prev_arc : arc;\n        circles.push(prev_arc);\n        t_s = prev_e;\n      } while (t_e < 1);\n      return circles;\n    }\n  };\n\n  module.exports = Bezier;\n})();\n"]},"metadata":{},"sourceType":"script"}
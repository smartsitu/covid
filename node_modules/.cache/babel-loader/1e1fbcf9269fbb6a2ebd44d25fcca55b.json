{"ast":null,"code":"import { useRef, useMemo, useEffect } from \"react\";\nvar checkedPkgs = {};\n\nvar checkStyles = function checkStyles() {};\n\nif (process.env.NODE_ENV !== \"production\") {\n  checkStyles = function checkStyles(pkg) {\n    // only check once per package\n    if (checkedPkgs[pkg]) return;\n    checkedPkgs[pkg] = true;\n\n    if (parseInt(window.getComputedStyle(document.body).getPropertyValue(\"--reach-\" + pkg), 10) !== 1) {\n      console.warn(\"@reach/\" + pkg + \" styles not found. If you are using a bundler like webpack or parcel include this in the entry file of your app before any of your own styles:\\n\\n    import \\\"@reach/\" + pkg + \"/styles.css\\\";\\n\\n  Otherwise you'll need to include them some other way:\\n\\n    <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"node_modules/@reach/\" + pkg + \"/styles.css\\\" />\\n\\n  For more information visit https://ui.reach.tech/styling.\\n  \");\n    }\n  };\n}\n\nexport { checkStyles };\nexport var wrapEvent = function wrapEvent(theirHandler, ourHandler) {\n  return function (event) {\n    theirHandler && theirHandler(event);\n\n    if (!event.defaultPrevented) {\n      return ourHandler(event);\n    }\n  };\n};\nexport var assignRef = function assignRef(ref, value) {\n  if (ref == null) return;\n\n  if (typeof ref === \"function\") {\n    ref(value);\n  } else {\n    try {\n      ref.current = value;\n    } catch (error) {\n      throw new Error(\"Cannot assign value \\\"\" + value + \"\\\" to ref \\\"\" + ref + \"\\\"\");\n    }\n  }\n};\nexport function useUpdateEffect(effect, deps) {\n  var mounted = useRef(false);\n  useEffect(function () {\n    if (mounted.current) {\n      effect();\n    } else {\n      mounted.current = true;\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, deps);\n}\nexport function useAssignRef(refA, refB) {\n  var ref = useMemo(function () {\n    if (refA == null && refB == null) {\n      return null;\n    }\n\n    return function (refValue) {\n      setRef(refA, refValue);\n      setRef(refB, refValue);\n    };\n  }, [refA, refB]); // We shouldn't really need to throw an error using this method AFAICT.\n  // TODO: We may want to consider phasing out `assignRef` in favor of this hook.\n\n  function setRef(ref, value) {\n    if (typeof ref === \"function\") {\n      ref(value);\n    } else if (ref) {\n      ref.current = value;\n    }\n  }\n\n  return ref;\n}","map":{"version":3,"sources":["/Users/maclaptop/Documents/GitHub/ashokpandey.com/node_modules/@reach/utils/es/index.js"],"names":["useRef","useMemo","useEffect","checkedPkgs","checkStyles","process","env","NODE_ENV","pkg","parseInt","window","getComputedStyle","document","body","getPropertyValue","console","warn","wrapEvent","theirHandler","ourHandler","event","defaultPrevented","assignRef","ref","value","current","error","Error","useUpdateEffect","effect","deps","mounted","useAssignRef","refA","refB","refValue","setRef"],"mappings":"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","sourcesContent":["import { useRef, useMemo, useEffect } from \"react\";\nvar checkedPkgs = {};\n\nvar checkStyles = function checkStyles() {};\n\nif (process.env.NODE_ENV !== \"production\") {\n  checkStyles = function checkStyles(pkg) {\n    // only check once per package\n    if (checkedPkgs[pkg]) return;\n    checkedPkgs[pkg] = true;\n\n    if (parseInt(window.getComputedStyle(document.body).getPropertyValue(\"--reach-\" + pkg), 10) !== 1) {\n      console.warn(\"@reach/\" + pkg + \" styles not found. If you are using a bundler like webpack or parcel include this in the entry file of your app before any of your own styles:\\n\\n    import \\\"@reach/\" + pkg + \"/styles.css\\\";\\n\\n  Otherwise you'll need to include them some other way:\\n\\n    <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"node_modules/@reach/\" + pkg + \"/styles.css\\\" />\\n\\n  For more information visit https://ui.reach.tech/styling.\\n  \");\n    }\n  };\n}\n\nexport { checkStyles };\nexport var wrapEvent = function wrapEvent(theirHandler, ourHandler) {\n  return function (event) {\n    theirHandler && theirHandler(event);\n\n    if (!event.defaultPrevented) {\n      return ourHandler(event);\n    }\n  };\n};\nexport var assignRef = function assignRef(ref, value) {\n  if (ref == null) return;\n\n  if (typeof ref === \"function\") {\n    ref(value);\n  } else {\n    try {\n      ref.current = value;\n    } catch (error) {\n      throw new Error(\"Cannot assign value \\\"\" + value + \"\\\" to ref \\\"\" + ref + \"\\\"\");\n    }\n  }\n};\nexport function useUpdateEffect(effect, deps) {\n  var mounted = useRef(false);\n  useEffect(function () {\n    if (mounted.current) {\n      effect();\n    } else {\n      mounted.current = true;\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, deps);\n}\nexport function useAssignRef(refA, refB) {\n  var ref = useMemo(function () {\n    if (refA == null && refB == null) {\n      return null;\n    }\n\n    return function (refValue) {\n      setRef(refA, refValue);\n      setRef(refB, refValue);\n    };\n  }, [refA, refB]); // We shouldn't really need to throw an error using this method AFAICT.\n  // TODO: We may want to consider phasing out `assignRef` in favor of this hook.\n\n  function setRef(ref, value) {\n    if (typeof ref === \"function\") {\n      ref(value);\n    } else if (ref) {\n      ref.current = value;\n    }\n  }\n\n  return ref;\n}"]},"metadata":{},"sourceType":"module"}